#ifndef METAMORPHCOLLECTION_H
#define METAMORPHCOLLECTION_H

#include <iostream>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <vector>
#include <math.h>
#include <map>
#include <string>
#include <cstring>
#include <algorithm>
#include "metamorph.h"
#include "fantomas.h"
#include "isNumber.h"

const int maxSc = 2;	           // number of Sc variables for each flavor
//const int maxpars = 100;           // length of minuit pars list
const int maxMet = 10;	           // maximum number of flavors allowed by xFitter
const int maxctrlpts = 8;              // maximum number of control points for a given flavor
const int maxScm = maxSc + maxctrlpts; // maximum allowed values in array Scm
//bool xFitterCollectionSet = false; // flag to determine if the Metamorph map has been created

class MetamorphCollection
// class object which contains functions are used to create, update,
// and return PDF values for a metamorph object corresponding to 
// specified flavors in the provided input card. Each metamorph object
// is created while reading the fantomas input cards. The metamorph
// objects are created inside the MetaVector, and then passed into
// MetaRoster as an element with iflavor mapped to it so the metamorph PDF
// values can be called for by particle ID.
{
private:
  std::vector <metamorph> MetaVector;   // Vector containing all metamorph objects for each flavor specified
  std::map <int, metamorph*> MetaRoster; // MetaRoster maps the flavor ID with the corresponding metamorph PDF
  std::map <int, int> iMetRoster;	 // Map of iMet to flavor ID to be used when updating parameters for given flavor

  int iMet = 0;	         // Number of metamorph functions
  int paraiMet = 0;      // variable used to select Scm parameters in MetamorphCollection::UpdateParameters()

  int iflavor[maxMet] = {0};  
  int Nm[maxMet] = {0};
  int MappingMode[maxMet] = {0};
  double xPower[maxMet] = {0};
  double Xs0[maxMet][maxctrlpts] = {{0}}, fp0[maxMet][maxctrlpts] = {{0}}, fm0[maxMet][maxctrlpts] = {{0}};
  double Xs[maxMet][maxctrlpts] = {{0}}, fp[maxMet][maxctrlpts] = {{0}}, fm[maxMet][maxctrlpts] = {{0}};
  std::string Scm0[maxMet][maxScm] = {{}};
  double Scm[maxMet][maxScm] = {{0}};
  // lk22 added vectors to help eliminate empty space for control points not used in calculations.
  std::vector<double> Xsvec;
  std::vector<double> fmvec;
  std::vector<double> fpvec;
  std::vector<double> Scmvec;

  double Xstmp[maxctrlpts] = {0};
  double Scmtmp[maxMet][maxScm] = {0};
  double fptmp[maxctrlpts] = {0};
  double fmtmp[maxctrlpts] = {0};

  std::string newflag = "NEW";	 // flag signaling to calculate PDF and use as control point for metamorph PDF
  std::string calcflag = "CALC"; // flag signaling to calculate PDF in the output card
  std::string fixflag = "FIX";	 // flag singlaing to use metamorph::Carrier(x) for control point in PDF calculation
  int k;			 // variable used to count the number of input control points for a given flavor
  int l;			 // variable used to count the number of control points used in a given metamorph
  int iPts[maxMet];	       	 // array containing # of entries for each flavor 

  // lk22 added strings to contain headers from fantomas card
  std::string flvheader[maxMet]; // array to store unique headers for each flavor in fantomas card
  std::string parsheader1;	 // header for first list of parameters in fantomas card
  std::string parsheader2;	 // header for second list of parameters in fantomas card

public:
  MetamorphCollection()
  {   
    MetaVector.reserve(maxMet);
    Xsvec.reserve(maxScm);
    Scmvec.reserve(maxScm);
    fpvec.reserve(maxScm);
    fmvec.reserve(maxScm);
  } // MetamorphCollection constructor


  void PushMember()
  // MetamorpCollection::PushMember() is called inside the MetamorphCollection::ReadCard() function. 
  // The initial values read from MetamorphCollection::ReadCard() are used to create an initial metamorph
  // object inside the vector MetaVector. The boundary conditions are defined as well for the 
  // MetaVector element and then the Modulator function is calculated, allowing for the initial 
  // PDF values to be calculated.
  // The vector element is stored inside of MetaRoster, mapping the flavor and the metamorph object which will be used
  // to easily access the PDF value of any given flavor from the card. Scm is used to calculate the metamorph objects
  // instead of Scm0 since Scm will be updated by MetamorphCollection::UpdateParams() when xFitter varies the parameters 
  // Sc and Sm.
  {
    std::string flagcheck;

    for (int i = 0; i < k; i++)
    // The for loop checks if Sm0 is a number. If Sm0 is found to be a number, then the 
    // input parameters for the corresponding control point will be pushed into a vector 
    // to eliminate empty entries caused by flagged points.
    // The vector calues  will be copied by the arrays used to calculate the metamorph 
    // objects for each flavor. 
    //
    // If Sm0 is not found to be a number, it will first check to see if it is set to the  
    // flag to return the metamorph PDF in the output card and not contribute to the metamorph.
    // If Sm0 is not set to the flag, the program will exit.
    {
      // lk22 Added routine to separate control points used for calculations from entire collective list            
      for (int i = 0; i < maxSc; i++) // loop copies Sc parameters initially read from ReadCard() to Scmtmp[iMet] array
      {
	double Sctmp = std::stod(Scm0[iMet][i]);
	Scmtmp[iMet][i] = Sctmp;
      }

      flagcheck = Scm0[iMet][i+maxSc];
      std::cout << "flagcheck = " << flagcheck << std::endl;

      if (isNumber(flagcheck) == true)
      {	
	Xstmp[i] = Xs0[iMet][i];
	Scmtmp[iMet][i+maxSc] = std::stod(flagcheck); // converts string to value
	fptmp[i] = fp0[iMet][i];
	fmtmp[i] = fm0[iMet][i];
	Xsvec.push_back(Xstmp[i]);
	Scmvec.push_back(Scmtmp[iMet][i+maxSc]);
	fmvec.push_back(fmtmp[i]);
	fpvec.push_back(fptmp[i]);

	l++;
      } // if (isNumber(flagcheck == true)

      if (isNumber(flagcheck) == false)
      {
	if (flagcheck == calcflag)
	{
	  std::cout << "Flag detected to calculate metamorph PDF for x = " << Xs0[iMet][i] << "\n";
	  std::cout << "Metamorph value will be calculated in 'output/steering_fantomas_out.txt'" << std::endl;
	}
	else if (flagcheck == newflag)
	{
	  std::cout << "Flag detected to calculate metamorph PDF for x = " << Xs0[iMet][i] << "\n";
	  std::cout << Xs0[iMet][i] << " will be used as a control point in xFitter calculation" << std::endl;

	  Xstmp[i] = Xs0[iMet][i];
	  Scmtmp[iMet][i+maxSc] = 0; // Sm value will be calculated 
	  fptmp[i] = fp0[iMet][i];
	  fmtmp[i] = fm0[iMet][i];
	  
	  l++;
	}
	else if (flagcheck == fixflag)
	{
	  std::cout << std::endl << "Special value detected for control point x = " << Xs0[iMet][i] << std::endl;
	  std::cout << "Using metamorph::f(x) = Carrier(x) for control point." << std::endl;

	  Xstmp[i] = Xs0[iMet][i];
	  Scmtmp[iMet][i+maxSc] = -9999; // flags metamorph to use carrier function for metamorph value
	  fptmp[i] = fp0[iMet][i];
	  fmtmp[i] = fm0[iMet][i];
	  Xsvec.push_back(Xstmp[i]);
	  Scmvec.push_back(Scmtmp[iMet][i+maxSc]);
	  fmvec.push_back(fmtmp[i]);
	  fpvec.push_back(fptmp[i]);

	  l++;
	}
	else
	{
	  std::cout << "Flag not set to CALC/FIX/NEW in 'fantomas_steering.txt'. Make sure Sm(i) is either " \
	    "a number or set as CALC/FIX/New to calculate metamorph PDF at the control point without having it " \
	    "contribute to the metamorph PDF in xFitter." << std::endl;
	  exit(3);
	}
      } // if (isNumber(flagcheck) == false)
    } // for (int i = 0; i < k; i++)

    std::size_t newcheck;

    for (int i = maxSc; i < maxScm; i++) // check where the flag NEW is in the array Scm0, if any flagged points
    {
      newcheck = Scm0[iMet][i].find(newflag);
      if (newcheck != std::string::npos)
	break;
    }

    if (newcheck == std::string::npos)
    {
      for (int i = 0; i < k; i++)
      {
	Xs[iMet][i] = Xsvec[i];
	Scm[iMet][i+maxSc] = Scmvec[i];
	fm[iMet][i] = fmvec[i];
	fp[iMet][i] = fpvec[i];
      }
    }

    if (newcheck != std::string::npos)
    {
      int Nmtmp = Nm[iMet]-1;	// decreases Nm input value to calculate metamorph without NEW flagged control point
      double Xsmetatmp[maxctrlpts] = {0};
      double Scmmetatmp[maxScm] = {0};
      double fmmetatmp[maxctrlpts] = {0};
      double fpmetatmp[maxctrlpts] = {0};
      
      for (int i = 0; i < maxSc; i++)
	Scmmetatmp[i] = Scmtmp[iMet][i];

      for (int i = 0; i < k; i++)
      {
	Xsmetatmp[i] = Xsvec[i];
	Scmmetatmp[i+maxSc] = Scmvec[i];
	fmmetatmp[i] = fmvec[i];
	fpmetatmp[i] = fpvec[i];
      }

      metamorph metatmp(Nmtmp, Xsmetatmp, (Scmmetatmp+2), Scmmetatmp, xPower[iMet]);
      metatmp.SetBoundary(MappingMode[iMet], fmmetatmp, fpmetatmp);
      metatmp.UpdateModulator();

      for (int i = 0; i < k; i++)
      {
	double xtmp = Xstmp[i];
	Scmtmp[iMet][i+maxSc] = metatmp.f(xtmp);
      }
    } // if (newcheck != std::string::npos)

    for (int i = 0; i < maxSc; i++)
      Scm[iMet][i] = Scmtmp[iMet][i];

    for (int i = 0; i < k; i++)
    {
      Xs[iMet][i] = Xstmp[i];
      Scm[iMet][i+maxSc] = Scmtmp[iMet][i+maxSc];
      fm[iMet][i] = fmtmp[i];
      fp[iMet][i] = fptmp[i];
    }
        
    MetaVector.emplace_back(Nm[iMet], (Xs[iMet]), (Scm[iMet]+maxSc), (Scm[iMet]), xPower[iMet]);
    MetaVector[iMet].SetBoundary(MappingMode[iMet], (fm[iMet]), (fp[iMet]));
    MetaVector[paraiMet].UpdateModulator();
    MetaRoster.insert( std::pair<int, metamorph*>(iflavor[iMet], &(MetaVector[iMet])) );

    Xsvec.clear();
    Scmvec.clear();
    fpvec.clear();
    fmvec.clear();
  } // MetamorphCollection::PushMember()
  
  void ReadCard()
  // MetamorphCollection::ReadCard will read the input parameters for a given flavor in the fantomas steering card file. 
  // Xs, fp, fm, iflavor, MappingMode, and xPower are overwritten each loop after the MetamorphCollection::PushMember() 
  // function is called and will be stored internally in the metamorph object created using the inital values. Sm and Sc  
  // are stored in a 2-dimensional array. The values are stored for each metamorph function. The initial values of Sm 
  // and Sc will shifted by minuit within xFitter since they are treated as pointers inside the metamorph objects.  
  { 
    std::ifstream fantosteerin;
    
    const int lstr = 1000;	// define memory allocation for str
    char str[lstr];             // used to copy blocks of input params and be copied by stream
    std::string dummy;		// string to dump lines that won't be read
    std::stringstream stream(std::ios_base::app|std::ios_base::in|std::ios_base::out); // used to read blocks of params

    fantosteerin.open("steering_fantomas.txt", std::ifstream::in); // Open Fantomas steering card in xFitter
    // fantosteerin.open("../steering_fantomas.txt", std::ifstream::in); // Open Fantomas steering card in standalone
    if (!fantosteerin.is_open())
    {
      std::cout << "Unable to open Fantomas input file" << std::endl;
      exit(3); // Exit program if fantomas steering card cannot be found
    }

    if (fantosteerin.is_open())
    {
      while (!fantosteerin.eof())
      { 
	getline(fantosteerin,flvheader[iMet]); // stores card header of each loop
	getline(fantosteerin,parsheader1); // skips metamorph info header
	
	fantosteerin >> iflavor[iMet] >> Nm[iMet] >> MappingMode[iMet] \
		     >> xPower[iMet] >> Scm0[iMet][0] >> Scm0[iMet][1]; // reads line containing minuit params

	fantosteerin.ignore();
	getline(fantosteerin,parsheader2); // skips initial metamorph param header

	fantosteerin.get(str,lstr,'#'); // copies entire block of input params into str to copy over to stream
	std::string strtemp;
	strtemp.assign(str);
	strtemp.pop_back(); // removes last empty line caused by delimiter in str
	stream.str(strtemp);	// copies string of input parameters into stringstream
      
	k = 0;			// resets number of input count
	l = 0;			// resets number of control point count
	while (!stream.eof()) 
	// while loop reads block of text of control point parameters in fantomas card. Each line in the
	// block of text is read line by line and the first two inputs are stored in Xstmp and Scmtmp.
	// isNumber() function checks if the input for Sm for a given control point is a number. If Scm is a 
	// number, then isNumber will return true where metamorph will use that control point to calculate
	// the metamorph function. If isNumber() returns false, Xs will be stored in XsCALC  to 
	// be used where the metamorph value will be calculated in the output card.
	{
	  std::string line;
	  std::stringstream streamtmp;
	  getline(stream, line); // reads next line in stream block.
	  streamtmp.str(line);	 // copies string line to stringstream to copy values over to variables.

	  // lk22 added if statements to assign default boundary conditions if no values are specified in input card.
          streamtmp >> Xs0[iMet][k] >> Scm0[iMet][k+2];
	  if (streamtmp.eof())
	  {
	    fp0[iMet][k] = INFINITY;
	    fm0[iMet][k] = 0;
	  }
	  else if (!streamtmp.eof())
	    streamtmp >> fp0[iMet][k] >> fm0[iMet][k];
         
	  streamtmp.clear();

	  k++;
	} // while (!streamtmp.eof())

  
	memset (str, 0, lstr);      // clears current content in str
	strtemp.clear();       	    // clears current content in strtemp
	stream.clear();             // clears current content in stream

	PushMember();	// Creates metamorph object with parameters read from card and pushes it into vector and map

	if (l != Nm[iMet]+1)
	{
	  std::cout << "Error: The number of entries does not match with the specified Nm value for iflavor = " \
		    << iflavor[iMet] << " inside fantomas steering card" << std::endl;
	  exit(3);
	} // if (k != Nm)

	iMetRoster.insert( std::pair<int, int>(iflavor[iMet], iMet) );
	iPts[iMet] = k;

	++iMet;		// Adds to the count of Metamorph objects in card file

      } // while (fantosteerin.!eof())
	
    } //if (fantosteerin.is_open())

    fantosteerin.close();

    std::cout << "Fantomas intput card read successfully... \n" << std::endl;

  } // MetamorphCollection::ReadCard()

  void UpdateParameters(const int ifl, double *pars)
  // MetamorphCollection::UpdateParameters will be called every time xFitter updates the minuit parameters. 
  // Sc and Sm values are recalculated every update by adding the change from minuit to the initial value from the cards.
  // The initial value for each minuit parameter is set to 0 inside minuit.in.txt so that only the change is
  // added. metamorph::UpdateModulator() is called after the values are changed to recalculate the metamorph PDFs inside 
  // MetaVector, which will then update the elements in MetaRoster.
  {
    std::map<int,int>::iterator it;
    it = iMetRoster.find(ifl);	// iterator used to locate if there is an entry with iflavor = ifl

    if (it != iMetRoster.end())	// returns error if entry for ifl is not found
    {
    }
    else
    {
      std::cout << "Metamorph not found for iflavor = " << ifl << "\n"
		<< "Enter initial parameters in Fantomas steering card before continuing" << std::endl;
      exit(3);
    }
    
    paraiMet = iMetRoster[ifl];

    for (int i = 0; i < maxSc; i++)
      Scm[paraiMet][i] = Scmtmp[paraiMet][i] + pars[i];
    for (int i = 0; i < Nm[paraiMet]+1; i++)
      Scm[paraiMet][i+maxSc] = Scmtmp[paraiMet][i+maxSc] + pars[i+maxSc];

    MetaVector[paraiMet].UpdateModulator();

  } // Metamorph::UpdateParameters
  
  double f(const int ifl, const double x)
  // metamorph::f(x) will be called for and act on the specified metamorph object for a given
  // flavor ifl. ifl will be defined inside of xFitter when the fantomas PDF for a given flavor
  // is called for.
  {
    double ftmp;

    std::map<int,metamorph*>::iterator it;
    it = MetaRoster.find(ifl);	// iterator used to locate if there is an entry with iflavor = ifl

    if (it != MetaRoster.end())	// returns error if entry for ifl is not found
    {
    }
    else
    {
      std::cout << "Metamorph not found for iflavor = " << ifl << "\n"
		<< "Enter initial parameters in Fantomas steering card before continuing" << std::endl;
      exit(3);
    }

    ftmp = MetaRoster[ifl]->f(x); // metamorph::f(x) acting on specified metamorph object
    return ftmp;
    
  } // MetamorphCollection::f

  double MellinMoment(int ifl, int MellinPower, int npts=10000)
  {
    double momenttmp = MetaRoster[ifl]->GetMellinMoment(MellinPower,npts);

    return momenttmp;
  } // MetamorphCollection::MellinMoment

  void WriteCard()
  // Create an output card for Fantomas using the updated parameters of Sc and Sm.
  {
    std::ofstream fantosteerout;
    fantosteerout.open ("output/steering_fantomas_out.txt", std::ofstream::out);
    // fantosteerout.open ("../steering_fantomas_out.txt", std::ofstream::out); // used for standalone

    if (fantosteerout.is_open())
    {
      fantosteerout << "# Output card file of Fantomas steering card \n" << std::endl;
      for (int i = 0; i < iMet; i++)
      // output fantomas parameters into out card and loop over each input flavor
      {
	fantosteerout << flvheader[i] << std::endl;
	fantosteerout << parsheader1 << std::endl;
	fantosteerout << iflavor[i] << "\t" << Nm[i] << "\t" << MappingMode[i] \
		      << "\t" << xPower[i] << "\t";
	for (int j = 0; j < maxSc; j++)            // loop that writes out all Sc parameter values
	  fantosteerout << Scm[i][j] << "\t";
	fantosteerout << std::endl;
	fantosteerout << parsheader2 << std::endl; // header for metamorph parameters
	for (int j = 0; j < iPts[i]; j++)          // loop that writes out all metamorph parameter values
	{
	  // lk22 added routine to printout all control point PDF values.
	  fantosteerout << Xs0[i][j];

	  if (Scm0[i][j+2] == calcflag)
	    fantosteerout << "\t" << MetaRoster[iflavor[i]]->f(Xs0[i][j]);
	  else
	    fantosteerout << "\t" << Scm[iMet][j+2];

	  if (fp[i][j] == INFINITY && fm[i][j] == 0 || fp[i][j] == 0 && fm[i][j] == 0)
	    fantosteerout << "\t" << "\t" << std::endl;
	  else if (fp[i][j] != INFINITY)
	    fantosteerout << "\t" << fp[i][j] << "\t" << fm[i][j] << std::endl;
	} // for (int j = 0; j < iPts[i]; j++)
      } // for (int i = 0; i < iMet; i++)
    } // if (fantosteerout.is_open())

    if (!fantosteerout.is_open())
      {
	std::cout << "Unable to open Fantomas output file" << std::endl;
	exit(3); // exit program if fantomas steering output card cannot be created
      }

    fantosteerout.close();

    std::cout << "\n Fantomas output card created successfully... \n" << std::endl;

  } // WriteCard()

  ~MetamorphCollection()
  {
    std::map<int,metamorph*>::iterator it;
    for(it = MetaRoster.begin(); it != MetaRoster.end(); ++it)
      MetaRoster.erase(it);
    MetaVector.clear();
    iMetRoster.clear();
  }
}; // class MetamorphCollection

#endif
